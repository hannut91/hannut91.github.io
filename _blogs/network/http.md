---
title: HTTP란 무엇인가?
subTitle:
category:
tags:
createdat: 2020-02-17 01:42:00
updatedat: 2020-02-17 01:42:00
---

## URI(Uniform Resource Identifiers)

스키마를 나타내는 리소스를 식별하기 위한 식별자.  

스키마는 리소스를 얻기 위한 수단에 이름을 붙이는 방법이다. 공식 URI 스키마는 ICANN 산하 조직인 IANA에 등록되어 있다.

## URL(Uniform Resource Locator)

리소스의 장소(네트워크 상의 위치)를 나타낸다. URL은 URI의 서브셋이다.  

절대적 위치를 나타내는 URL과 상대적 위치를 나타내는 상대 URL이 있다.

http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1

http, https 같은 스키마를 사용하여 리소스를 얻기 위해 사용하는 프로토콜을 명시한다. 대문자, 소문자는 무시되고 마지막에 `:`문자가 붙는다. `data:`와 `javascript:`와 같은 데이터와 프로그램을 지정할 수도 있다.  

user:pass는 자격정보를 나타내는데 서버로부터 리소스를 취득하기 위해 Credential이 필요할 경우 지정할 수 있다.  

www.example.com은 서버 주소로 도메인 명이나 `192.168.1.1`과 같이 IPv4 주소나 `[0:0:0:0:0:0:0:1]`과 같이 IPv6 주소를 명시할 수 있다.  

서버 포트를 지정할 수 있는데 생략하면 기본 포트가 사용된다.  

`/dir/index.html`은 특정 리소스를 식별하기 위해 서버 상의 경로를 지정한다.  

지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리 문자열을 사용할 수 있다.  

`#ch1`은 프래그맨트 식별자 인데, 주로 취득한 리소스에서 서브 리소스를 가리키기 위해서 사용된다.

## HTTP

HTTP는 클라이언트와 서버 간에 통신을 한다. 리소스를 요청하는 쪽이 클라이언트가 되고 리소스를 제공하는 쪽이 서버가 된다. 반드시 클라이언트 측으로부터 통신이 시작된다. 요청 없이 리스폰스를 송신하는 일은 없다.

## Stateless

HTTP는 상태를 계속 유지하지 않는 Stateless 프로토콜이다. HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다. 이는 많은 데이터를 매우 빠르고 확실하게 처리하는 Scalability를 확보하기 위해서 이와 같이 간단하게 설계되어 있다.  

상태를 계속 유지하고 싶은 요구에 부응하기 위해 Cookie라는 기술이 도입됐다.

## Method

메서드는 대문자와 소문자를 구별하기 때문에 대문자로 써야 한다.

* GET
  * 리소스를 가져올 수 있도록 요구한다.
* POST
  * 엔티티를 전송한다.
* PUT
  * 파일을 전송한다.
* HEAD
  * 메시지 헤더를 요청한다. GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다.
  * URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.
* DELETE
  * 파일 삭제에 사용된다.
* OPTIONS
  * 제공하고 있는 메서드를 조사하기 위해 사용된다.
* CONNECT
  * 프록시에 터널 접속을 확립을 요청해서 TCP 통신을 터널링 하기 위해 사용된다.
  * 주로 SSL과 TLS 등의 프로토콜로 암호화된 것을 터널링 시키기 위해 사용된다.

## 지속 연결(Persistent Connections)

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 했다. 매번 연결하고 종료하는 낭비가 늘어나서 지속 연결(Persistent Connections)이라는 방법이 나왔다.  

어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.  

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다. 파이프라인화에 의해서 이전에 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 요청하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다. 이로 인해 여러 리퀘스트를 병행해서 보내는 것이 가능하다.

## Cookie

HTTP는 Stateless 프로토콜이라서 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않는다.  

쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다. 쿠키는 서버에서 리스폰스로 보내진 `Set-Cookie`라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다. 다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때 자동으로 쿠키 값을 넣어서 송신한다. 서버는 클라이언트가 보낸 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있다.

## HTTP message

메시지 헤더와 메시지 바디로 구성되어 있다. 최초에 나타나는 개행 문자로 메시지 헤더와 메시지 바디를 구분한다.

### HTTP Request message

![](/images/HTTP_Request_Headers.png)

리퀘스트 메시지는 메서드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성되어 있다.

### HTTP Response message

![](/images/HTTP_Response_Headers.png)

리스폰스 메시지는 프로토콜 버전, 상태 코드, 상태 코드 설명, 옵션의 리스폰스 헤더 필드와 바디로 구성되어 있다.

### 인코딩

HTTP로 데이터를 전송할 때 그대로 전송할 수 있지만 전송할 때에 인코딩을 실시함으로써 전송 효율을 높일 수 있다. 하지만 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다.

* 메시지
  * HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.
* 엔티티
  * 리퀘스트와 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

HTTP 메시지 바디의 역할은 리퀘스트와 리스폰스에 관한 엔티티 바디를 운반하는 일이다. 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다.

### 콘텐츠 코딩(Content Codings)

용량을 줄이기 위해서 파일을 zip으로 압축하고 보낼 수 있다. 콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한 채로 압축한다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩 된다.

* gzip(GNU zip)
* compress(UNIX의 표준 압축)
* deflate(zlib)
* identity(인코딩 없음)

### 청크 전송 코딩(Chunked transfer Coding)

엔티티 바디를 분할하는 기능을 말한다. 엔티티 바디를 청크로 분해하고 다음 청크 사이즈를 16진수를 사용해서 단락을 표시하고 엔티티 바디 끝에는 `0(CR+LF)`를 기록한다. 청크 전송 코딩된 바디는 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩 한다.

### Multipart

MIME(Multipurpose Internet Mail Extensions)으로 불리는 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다. MIME는 이미지 등의 바이너리 데이터를 아스키(ASCII) 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있다. 이 MIME 확장 사양에 있는 Multipart라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있다.  

HTTP도 Multipart에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다. 주로 이미지나 텍스트 파일 등을 업로드할 때 사용되고 있다.

* multipart/form-data
  * Web 폼으로부터 파일 업로드에 사용된다.
* multipart/byteranges
  * 상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함할 때 사용된다.

### Ragnge Request

대용량의 이미지와 데이터를 다운로드할 때 중간에 커넥션이 끊어지게 되면 처음부터 다시 다운로드해야 했다. 이러한 문제를 해결하기 위해 resume 기능이 필요하게 되었다. 이 기능으로 이전에 다운로드를 한 곳에서부터 다시 다운로드를 재개할 수 있다.  

이 기능을 실현하기 위해 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 이와 같이 범위를 지정하여 리퀘스트 하는 것을 Range Request라고 한다.

### Content Negotiation

클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것을 말한다. 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조다. 메시지에 포함된 다음 리퀘스트 헤더 필드를 이용한다.

* Accept
* Accept-Charset
* Accept-Encoding
* Accept-Language
* Content-Language

## Sources

* <http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788931447897>
