<!doctype html>

<html class="no-js" lang="en">

<head>


	<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	Yunseok's Dev Blog

	Simples Theme by https://jekyllthemes.io
	Premium + free Jekyll themes for your blog or website.

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<!-- Page Info -->
	<link rel="shortcut icon" href="/images/favicon.png">
	<title>Express Production Best Practices – Yunseok's Dev Blog</title>
	<meta name="description" content="Production best practices performance and reliability">

	<!-- Twitter Card -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="Express Production Best Practices – Yunseok's Dev Blog">
	<meta name="twitter:description" content="Production best practices performance and reliability">
	<meta name="twitter:image:src" content="http://localhost:4000">

	<!-- Facebook OpenGraph -->
	<meta property="og:title" content="Express Production Best Practices – Yunseok's Dev Blog" />
	<meta property="og:description" content="Production best practices performance and reliability" />
	<meta property="og:image" content="http://localhost:4000" />

	
	<!-- Font Embed Code -->
	<link href="https://fonts.googleapis.com/css?family=Nunito:300,400,400i,600" rel="stylesheet">
	

	<!-- Styles -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="/css/style.css">
	
	<!-- Icons -->
	<script defer src="https://use.fontawesome.com/releases/v5.1.1/js/solid.js" integrity="sha384-GXi56ipjsBwAe6v5X4xSrVNXGOmpdJYZEEh/0/GqJ3JTHsfDsF8v0YQvZCJYAiGu" crossorigin="anonymous"></script>
	<script defer src="https://use.fontawesome.com/releases/v5.1.1/js/brands.js" integrity="sha384-0inRy4HkP0hJ038ZyfQ4vLl+F4POKbqnaUB6ewmU4dWP0ki8Q27A0VFiVRIpscvL" crossorigin="anonymous"></script>
	<script defer src="https://use.fontawesome.com/releases/v5.1.1/js/fontawesome.js" integrity="sha384-NY6PHjYLP2f+gL3uaVfqUZImmw71ArL9+Roi9o+I4+RBqArA2CfW1sJ1wkABFfPe" crossorigin="anonymous"></script>

	
	<!-- Custom Styles -->
	<style></style>
	

	
	<!-- Analytics Code -->
	
	

	
	<!-- Extra Header JS Code -->
	
	
	
</head>


<body class="loading ajax-loading" data-site-url="http://localhost:4000" data-page-url="/blogs/express/14.production-best-pratices">


	<header class="header">

	<div class="wrap">

		
		<a href="/" class="header__avatar">
			<img src="/images/profile.jpg" class="header__avatar__img">
		</a>
		

		
		<a href="/" class="header__title">
			Yunseok's Dev Blog
		</a>
		

		<p class="header__tagline">배운 것을 적는 블로그입니다.</p>

		<div class="menu">
			<ul class="menu__list">
				
				<li class="menu__list__item">
					<a href="/" class="menu__list__item__link">Latest</a>
				</li>
				
				<li class="menu__list__item">
					<a href="/about" class="menu__list__item__link">About</a>
				</li>
				
			</ul>
		</div>

	</div>

</header>


	<div class="loader"><svg width="120" height="30" viewBox="0 0 120 30" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite" /><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite" /></circle><circle cx="60" cy="15" r="9" fill-opacity="0.3"><animate attributeName="r" from="9" to="9" begin="0s" dur="0.8s" values="9;15;9" calcMode="linear" repeatCount="indefinite" /><animate attributeName="fill-opacity" from="0.5" to="0.5" begin="0s" dur="0.8s" values=".5;1;.5" calcMode="linear" repeatCount="indefinite" /></circle><circle cx="105" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite" /><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite" /></circle></svg></div>

	<div class="page-loader"></div>

	
	<div class="page">

		<div class="page__content" data-page-title="Express Production Best Practices – Yunseok's Dev Blog" data-image="">

			<section class="single">

	<div class="wrap">

		<h1>Express Production Best Practices</h1>
		<p class="subtitle"></p>

		<h2 id="performance">Performance</h2>

<h3 id="use-gzip-compression">Use gzip compression</h3>

<ul>
  <li>Gzip 압축은 응답 바디의 사이즈를 줄일 수 있어서 웹 앱의 속도를 높일 수
있습니다.</li>
  <li><a href="https://www.npmjs.com/package/compression">compression</a> 미들웨어는
Gzip압축을 지원하는 미들웨어 입니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">compression</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'compression'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">()</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">compression</span><span class="p">())</span>
</code></pre></div></div>

<ul>
  <li>트레픽이 많은 웹사이트의 경우 더 좋은 방법은 reverse proxy 레벨에서 압축을
사용하는 것입니다.(<a href="http://expressjs.com/en/advanced/best-practice-performance.html#use-a-reverse-proxy">Use a reverse proxy</a>)</li>
  <li>그럴 경우 미들웨어에서 압축을 사용할 필요가 없습니다.</li>
  <li>Nginx에서 Gzip압축을 사용하려면 다음을 참고하세요: <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">Module ngx_http_gzip_module</a></li>
</ul>

<h3 id="dont-use-synchronous-functions">Don’t use synchronous functions</h3>

<ul>
  <li>동기함수, 메소드는 일이 끝날 때 까지 프로세스를 묶어놓습니다. 동기함수로
하나의 요청은 밀리초, 마이크로초에 처리가 끝날 수 있지만 높은 트래픽
웹사이트에서는 앱의 성능을 저하시킵니다.</li>
  <li>Node가 동기, 비동기버전의 함수들을 지원하더라도 항상 비동기함수를
사용해야합니다. 유일하기 동기함수를 사용할 수 있는 곳은 처음 서버가 시작될 때
뿐입니다.</li>
  <li>만약 Node.js 4.0이상을 쓰고 io.js 2.1.0이상을 쓰고 있다면
<code class="highlighter-rouge">--trace-sync-io</code>플래그를 사용하면 앱이 동기API를 호출하는 것을 확인할 수
있습니다.</li>
</ul>

<h3 id="do-logging-correctly">Do logging correctly</h3>

<ul>
  <li>일반적으로 로깅을 하는 이유는 디버깅의 목적과 앱의 활동을 기록하는것입니다.</li>
  <li>개발할 때 <code class="highlighter-rouge">console.log()</code>와 <code class="highlighter-rouge">console.error()</code>를 사용합니다. 하지만 이
함수들은 터미널 혹은 파일로 출력할 때 동기 함수들입니다. 그래서 배포할 때는
적합하지 않습니다.</li>
</ul>

<h4 id="for-debugging">For debugging</h4>

<ul>
  <li>디버깅을 목적으로 한다면 <code class="highlighter-rouge">console.log()</code>보다는 <a href="https://www.npmjs.com/package/debug">debug</a>를 사용하는 것이 좋습니다. 이 모듈은 <code class="highlighter-rouge">DEBUG</code>환경 변수를 사용하고
앱이 비동기적으로 동작하도록 해줍니다.</li>
</ul>

<h4 id="for-app-activity">For app activity</h4>

<ul>
  <li>앱활동을 기록하려면 <code class="highlighter-rouge">console.log</code>대신 로깅 라이브러리를 사용하는 것이
좋습니다.
    <ul>
      <li><a href="https://www.npmjs.com/package/winston">Winston</a></li>
      <li><a href="https://www.npmjs.com/package/bunyan">Bunyan</a></li>
    </ul>
  </li>
</ul>

<h3 id="handle-execeptions-properly">Handle execeptions properly</h3>

<p>에외를 처리하지 않고 적적한 조치를 취하지 않으면 <code class="highlighter-rouge">Express</code>앱은 다운되고
종료됩니다. 따라서 예외들을 적절히 처리해야합니다.
Node/Express는 두 가지 방식으로 에러를 처리합니다.</p>
<ul>
  <li>Error-first callbacks</li>
  <li>Propagating errors in middleware</li>
</ul>

<p>Node는 비동기 함수에서 첫 번째 인자로 에러를 반환하고 나머지 반환할 값들을
반환합니다. 만약 에러가 발생하지 않는다면 null을 첫 번째 인자로 반한합니다.
callback함수는 반드시 <code class="highlighter-rouge">error-frist callback</code>컨벤션을 지켜야합니다.
Express에서는 <code class="highlighter-rouge">next()</code>함수를 사용하여 에러를 전파하는 것이 best practice입니다.</p>

<p>에러처리에 대한 자세한 내용들은 다음을 참고하세요.</p>
<ul>
  <li><a href="https://www.joyent.com/developers/node/design/errors">Error Handling in Node.js</a></li>
  <li><a href="https://strongloop.com/strongblog/robust-node-applications-error-handling/">Building Robust Node Applications: Error Handling</a></li>
</ul>

<h4 id="what-not-to-do">What not to do</h4>

<p>당신이하지 말아야 할 일 중 하나는 uncaughtException 이벤트를 수신하는 것입니다.
예외가 발생하면 예외가 이벤트 루프로 되돌아갑니다.
<code class="highlighter-rouge">uncaughtException</code>을 event listener에 등록하는 것은 프로세스의 기본행동을
변경하게 됩니다. 그러면 프로세스는 예외가 발생해도 계속 실행하게 됩니다. 언듯
듣기에는 앱이 멈추는 것을 방지하기 떄문에 좋아 보이지만 예상치못한 에러가
발생했을 때 프로그램이 계속 실행되는 것은 굉장히 위험한 일입니다.</p>

<h4 id="use-try-catch">Use try-catch</h4>

<p>Try-catch는 동기 코드에서 예외를 catch하는 데 사용할 수있는 JavaScript 언어
구문입니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'/search'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Simulating async operation</span>
  <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">jsonStr</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">params</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">jsonObj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">)</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Success'</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">400</span><span class="p">).</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Invalid JSON string'</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>하지만 <code class="highlighter-rouge">Try-catch</code>는 동기코드에서만 동작합니다. <code class="highlighter-rouge">Node</code>는 주로 비동기적으로
프로그램을 작성하므로 많은 예외를 처리하지 못합니다.</p>

<h4 id="use-promises">Use promises</h4>

<p><code class="highlighter-rouge">promise</code>들은 어떤 예외든 <code class="highlighter-rouge">catch(next)</code>로 처리합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do some sync stuff</span>
  <span class="nx">queryDb</span><span class="p">()</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// handle data</span>
      <span class="k">return</span> <span class="nx">makeCsv</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">csv</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// handle csv</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// handle error</span>
<span class="p">})</span>
</code></pre></div></div>

<p>모든 동기, 비동기에러들이 에러미들웨어로 전파됩니다. 하지만 두가지 주의해야 할
것이 있습니다.</p>
<ul>
  <li>모든 비동기 코드들은 <code class="highlighter-rouge">promise</code>를 맄턴해야합니다. 특정한 라이브러리가
<code class="highlighter-rouge">promise</code>를 반환하지 않는다면 <code class="highlighter-rouge">promise</code>로 변경해야합니다.</li>
  <li>Event emiiter들은 여전히 처리되지않은 예외들이 있습니다. 따라서 에러 이벤트를
적절히 처리하고 있는지 확인해야합니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">wrap</span> <span class="o">=</span> <span class="nx">fn</span> <span class="o">=&gt;</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="nx">wrap</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">company</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getCompanyById</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">getLogoStreamById</span><span class="p">(</span><span class="nx">company</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
  <span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">next</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">wrap()</code>함수는 reject된 promise들을 처리하고 <code class="highlighter-rouge">next()</code>함수를 호출합니다.</p>

<h2 id="set-node_env-to-production">Set NODE_ENV to ‘production’</h2>

<p><code class="highlighter-rouge">NODE_ENV</code>환경변수는 어플리케이션이 동작하는 환경을 나타냅니다. 일반적으로
<code class="highlighter-rouge">development</code>와 <code class="highlighter-rouge">environment</code>가 있습니다.
성능을 올리는데 가장 간단한 것은 <code class="highlighter-rouge">NODE_ENV</code>를 <code class="highlighter-rouge">production</code>으로 설정하는
것입니다.
Express에서 <code class="highlighter-rouge">NODE_ENV</code>를 <code class="highlighter-rouge">production</code>으로 할 경우</p>
<ul>
  <li>view템플릿들을 캐싱합니다.</li>
  <li>CSS extension로부터 생성된 CSS파일들을 캐싱합니다.</li>
  <li>에러메세시지들을 자세하게 표시하지 않습니다.</li>
</ul>

<p><a href="https://www.dynatrace.com/news/blog/the-drastic-effects-of-omitting-node-env-in-your-express-js-applications/">Test indicate</a>에서 테스트결과를 확인할 수 있습니다.
환경에 따라 다른 코드를 작성하고 싶다면 <code class="highlighter-rouge">process.env.NODE_ENV</code>를 확인하여
작성할 수 있습니다.</p>

<h2 id="ensure-your-app-automatically-restarts">Ensure your app automatically restarts</h2>

<p>production에서는 어플리케이션이 종료되는 것을 원치 않습니다. 만약 앱이 멈추면
앱은 재시작해야 합니다.</p>
<ul>
  <li>프로세스 매니저를 사용하여 앱이 종료되었을 때 재시작합니다.</li>
  <li>OS에 있는 초기화 시스템으로 프로세스 매니저를 재시작합니다.</li>
</ul>

<p>노드 애플리케이션은 처리되지 않은 예외가 있을 때 멈춥니다. 예외를 모두 처리하는
것이 더 중요하지만 만약 앱이 종료되었을 때 다시 시작하는 것이 필요합니다.</p>

<h3 id="use-process-manager">Use process manager</h3>

<p>개발할 때는 CLI에서 서버를 실행시킵니다. 하지만 production에서 이렇게 하면
안됩니다. 앱이 멈추면 다시 시작할 떄 까지 서비스가 멈추게 됩니다. 앱이 멈추었을
때 다시 시작하도록 프로세스 매니저를 사용하는 것이 좋습니다.
프로세스 매니저는 애플리케이션들을 위한 컨테이너로 배포와 높은 가용성, 그리고
애플리케이션을 관리할 수 있도록 도와줍니다.
프로세스매니저는 단순히 앱을 재시작 하는 기능 뿐만 아니라 다음같은 기능들도
제공합니다.</p>
<ul>
  <li>자원소비와 실행 성능의 정보를 볼 수 있습니다.</li>
  <li>성능향상을 위해 동적으로 설정을 변경할 수 있습니다.</li>
  <li>클러스터링을 관리합니다.</li>
</ul>

<p>가장 유명한 프로세스 매니저들은 다음과 같습니다.</p>
<ul>
  <li><a href="http://strong-pm.io/">StrongLoop Process Manager</a></li>
  <li><a href="https://github.com/Unitech/pm2">PM2</a></li>
  <li><a href="https://www.npmjs.com/package/forever">Forever</a></li>
</ul>

<h2 id="sources">Sources</h2>

<ul>
  <li><a href="http://expressjs.com/en/advanced/best-practice-performance.html">http://expressjs.com/en/advanced/best-practice-performance.html</a></li>
</ul>


	</div>

</section>


		</div>

	</div>


	<footer class="footer">

	<ul class="socials">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<li class="socials__item">
		<a href="https://www.github.com/hannut91" target="_blank" class="socials__item__link" title="Github">
			<i class="fab fa-github" aria-hidden="true"></i>
		</a>
	</li>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</ul>

	<div class="footer__copyright">
		<span>© 2019 Yunseok's Dev Blog</span>
		<a href="https://jekyllthemes.io" target="_blank">Jekyll Themes</a>
	</div>

</footer>


	<!-- Javascript Assets -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<script src="/js/simples-min.js"></script>

	
	<!-- Extra Footer JS Code -->
	
	


</body>

</html>
